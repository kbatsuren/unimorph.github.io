<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml"> 
  <head> 
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" /> 
    <meta http-equiv="cache-control" content="no-cache" /> 
    <title> 
      Bibtex-js Demo
    </title>
    
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/pcooksey/bibtex-js/b81606e85986fa8ad0eb66954493bc1c0b3d7ab1/src/bibtex_js.js"></script>
    
    <style>
    body{ font: 80% "Trebuchet MS", sans-serif; margin: 10px;}
    textarea { font-size: 8pt; width: 500px; height: 150px; }
    #bibtex_errors { margin-top:10px; color: red;}
    h1 { font-size: 12pt; margin-top:20px; }
    </style>
  </head>
<body>
  
<h1> BibTeX Input </h1>
<textarea id="bibtex_input">
  @book{sammet2003programming,
    title={{Programming languages}},
    author={Sammet, J.E. and Hemmendinger, D.},
    year={2003},
    publisher={John Wiley and Sons Ltd.}
  }

  @book{bauer1998ubersetzung,
    title={Übersetzung objektorientierter Programmiersprachen: Konzepte, abstrakte Maschinen und Praktikum \glqq Java Compiler\grqq},
    author={Bauer, B. and Höllerer, R.},
    year={1998},
    publisher={Springer}
  }

  @article{parr1995antlr,
    title={{ANTLR: A predicated-LL (k) parser generator}},
    author={Parr, T.J. and Quong, R.W.},
    journal={Software-Practice and Experience},
    volume={25},
    number={7},
    pages={789--810},
    year={1995},
    publisher={Citeseer}
  }

  @book{ginsburg1975algebraic,
    title={{Algebraic and automata-theoretic properties of formal languages}},
    author={Ginsburg, S.},
    year={1975},
    publisher={Elsevier Science Inc. New York, NY, USA}
  }

  @misc{ wiki:chomskyh,
    author = "Wikipedia",
    title = "Chomsky-Hierarchie --- Wikipedia{,} Die freie Enzyklopädie",
    year = "2010",
    url = "\url{http://de.wikipedia.org/w/index.php?title=Chomsky-Hierarchie&oldid=71123007}",
    note = "[Online; Stand 11. März 2010]"
  }

  @misc{ wiki:ebnf,
    author = "Wikipedia",
    title = "Extended Backus-Naur Form --- Wikipedia{,} The Free Encyclopedia",
    year = "2010",
    url = "\url{http://en.wikipedia.org/w/index.php?title=Extended_Backus%E2%80%93Naur_Form&oldid=348946400}",
    note = "[Online; accessed 11-March-2010]"
  }



  @article{schning2001theoretische,
    title={{Theoretische Informatik kurzgefasst, 4}},
    author={Schning, U.},
    journal={Auflage. Spektrum-Verlag},
    year={2001}
  }

  @book{grune2008parsing,
    title={{Parsing techniques: a practical guide}},
    author={Grune, D. and Jacobs, C.J.H.},
    year={2008},
    publisher={Springer-Verlag New York Inc}
  }

  @misc{ wiki:pda,
    author = "Wikipedia",
    title = "Pushdown automaton --- Wikipedia{,} The Free Encyclopedia",
    year = "2010",
    url = "\url{http://en.wikipedia.org/w/index.php?title=Pushdown_automaton&oldid=343378592}",
    note = "[Online; accessed 17-March-2010]"
  }

  @book{ullman,
    title={{Introduction to automata theory, languages, and computation}},
    author={Hopcroft, J.E. and Motwani, R. and Ullman, J.D.},
    year={2006},
    publisher={Addison-wesley}
  }

  @misc{linde,
    author ="Kai Linde",
    title = "Analyse des Einsatzes moderner Programmierparadigmen in der Roboterstuerung",
    year = "2007"
  }

  @misc{expertenhandbuch,
    author = "KUKA Roboter GmbH",
    title = "Programmierung Experte KUKA System Software (KSS) R5.4",
    year = "2005",
    note = "Stand: 23.02.2005   Version: 00"
  }

  @article{saraswat1997java,
    title={{Java is not type-safe}},
    author={Saraswat, V.},
    journal={manuscript, AT\&T Research, New York},
    year={1997},
    publisher={Citeseer}
  }

  @book{ANTLR,
    author = {Terence Parr},
    edition = {First},
    interhash = {d9ef4ed82183b86b6a3004161de5ea44},
    intrahash = {1688029f4c14bd3b234933a48e902c03},
    publisher = {Pragmatic Bookshelf},
    series = {Pragmatic Programmers},
    title = {The Definitive ANTLR Reference: Building Domain-Specific Languages},
    url = {http://www.amazon.com/Definitive-ANTLR-Reference-Domain-Specific-Programmers/dp/0978739256%3FSubscriptionId%3D13CT5CVB80YFWJEPWS02%26tag%3Dws%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0978739256},
    year = 2007,
    ean = {9780978739256},
    keywords = {Me:MastersThesis antlr compilers languages lexers parsers programming},
    asin = {0978739256},
    description = {Amazon.com: The Definitive ANTLR Reference: Building Domain-Specific Languages (Pragmatic Programmers): Terence Parr: Books},
    isbn = {0978739256},
    biburl = {http://www.bibsonomy.org/bibtex/21688029f4c14bd3b234933a48e902c03/gron},
    dewey = {005.45},
    month = May
  }

  @article{parr1996ll,
    title={{LL and LR translators need k> 1 lookahead}},
    author={Parr, T.J. and Quong, R.W.},
    journal={ACM Sigplan Notices},
    volume={31},
    number={2},
    pages={27--34},
    year={1996},
    publisher={ACM}
  }

  @book{dragoonBook,
    author = {Alfred V. Aho and Monica S. Lam and Ravi Sethi and Jeffrey D. Ullman},
    howpublished = {Hardcover},
    interhash = {6bc8d88ce1094de53ec7ec47b7ba4973},
    intrahash = {c3bc558a481f3cf0445068988a80f1b2},
    publisher = {{Addison Wesley}},
    title = {Compilers: Principles, Techniques, and Tools (2nd Edition)},
    url = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0321486811},
    year = 2006,
    keywords = {compilers},
    posted-at = {2009-05-19 16:04:16},
    description = {CiteULike: Everyone's library},
    priority = {2},
    isbn = {0321486811},
    biburl = {http://www.bibsonomy.org/bibtex/2c3bc558a481f3cf0445068988a80f1b2/earthfare},
    citeulike-article-id = {1033375},
    month = {August}
  }


  @article{Knuth:1965:LR,
      author = {Knuth, Donald},
      citeulike-article-id = {5914311},
      journal = {Information and Control},
      keywords = {parsing},
      pages = {607--639},
      posted-at = {2009-10-09 06:17:47},
      priority = {2},
      title = {On the Translation of Languages from Left to Right},
      volume = {8},
      year = {1965}
  }


  @MISC{antlr:targets,
        AUTHOR = "Terance Parr et al",
        TITLE = "ANTLR code generation targets",
        MONTH = "May",
        YEAR = {2010},
        NOTE = "\url{http://www.antlr.org/wiki/display/ANTLR3/Code+Generation+Targets?focusedCommentId=23232603#comment-23232603}"
  }

  @MISC{antlr:works,
        AUTHOR = "Jean Bovet and Terance Parr",
        TITLE = "ANTLRWorks: An ANTLR Grammar Development Environment",
        MONTH = "July",
        YEAR = {2007},
        NOTE = "\url{http://www.antlr.org/papers/antlrworks-draft.pdf}"
  }

  @MISC{antlr:keywords,
        AUTHOR = "Terance Parr",
        TITLE = "How can I allow keywords as identifiers?",
        MONTH = "June",
        YEAR = {2008},
        NOTE = "\url{http://www.antlr.org/wiki/pages/viewpage.action?pageId=1741}"
  }

  @misc{ wiki:ast,
    author = "Wikipedia",
    title = "Abstract syntax tree --- Wikipedia{,} The Free Encyclopedia",
    year = "2010",
    url = "\url{http://en.wikipedia.org/w/index.php?title=Abstract_syntax_tree&oldid=351440895}",
    note = "[Online; accessed 30-March-2010]"
  }

  @misc{lrpdf,
    author = "Andreas Kunert",
    title = "LR Parser für Pragmatiker",
    year = "2008",
    url = "\url{http://www2.informatik.hu-berlin.de/~kunert/papers/lr-analyse/}"
  }

  @book{LangImplPatterns,
      abstract = {Learn to build configuration file readers, data readers, model-driven code generators, source-to-source translators, source analyzers, and interpreters. You don't need a background in computer science-ANTLR creator Terence Parr demystifies language implementation by breaking it down into the most common design patterns. Pattern by pattern, you'll learn the key skills you need to implement your own computer languages.},
      author = {Parr, Terence},
      keywords = {language\_implementation},
      priority = {0},
      publisher = {The Pragmatic Bookshelf},
      title = {Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages},
      year = {2009}
  }

  @article{lua,
    author =     "R. Ierusalimschy and L.H. de Figueiredo and W. Celes",
    title =      "The Implementation of Lua 5.0",
    abstract =   "We discuss the main novelties of the   implementation of Lua 5.0: its register-based virtual machine, the   new algorithm for optimizing tables used as arrays, the   implementation of closures, and the addition of   coroutines.",
    journal =    "Journal of Universal Computer Science",
    year =       "2005",
    volume =     "11",
    number =     "7",
    pages =      "1159--1176"
    }



  @misc{treebased-interpreter,
  AUTHOR = "Terance Parr",
  TITLE = "Tree based interpreters",
  MONTH = "May",
  YEAR = {2009},
  NOTE = "\url{http://www.antlr.org/wiki/display/ANTLR3/The+difference+between+compilers+and+interpreters}"
  }
</textarea>
<div id="bibtex_errors"></div>

<h1> Template </h1>
<textarea id="bibtex_template_input">
<div class="if author" style="font-weight: bold;">
  <span class="if year">
    <span class="year"></span>, 
  </span>
  <span class="author"></span>
  <span class="if url" style="margin-left: 20px">
    <a class="url" style="color:black; font-size:10px">(view online)</a>
  </span>
</div>
<div style="margin-left: 10px; margin-bottom:5px;">
  <span class="title"></span>
</div>
</textarea>

<div class="bibtex_template"></div>

<h1> Rendered </h1>

<div id="bibtex_display">
</div>

<script type="text/javascript" charset="utf-8">
  refresh = false;
  window.setInterval(function() {
    if (refresh) {
      try {
        $("#bibtex_errors").html("");
        bibtex_js_draw();
      } catch (err) {
        $("#bibtex_errors").html(err.substring(0, 100) + "...");
      }
      refresh = false;
    }
  }, 500);
  // monitor template for changes and add template to dom
  $("#bibtex_template_input").keyup(function() {
    $(".bibtex_template").html($("#bibtex_template_input").val());
    refresh = true;
  });
  $(".bibtex_template").html($("#bibtex_template_input").val());
  
  // monitor bibtex for changes and redraw
  $("#bibtex_input").keyup(function() {
    refresh = true;
  });
</script>

</body>
</html>
Raw
 bibtex-js.js
//The MIT License (MIT)
//
//Copyright (c) <year> <copyright holders>
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.
//
// Author: Rahul Potharaju
// Original Author: Henrik Muehe
// Issues:
//  no comment handling within strings
//  no string concatenation
//  no variable values yet

// Grammar implemented here:
//  bibtex -> (string | preamble | comment | entry)*;
//  string -> '@STRING' '{' key_equals_value '}';
//  preamble -> '@PREAMBLE' '{' value '}';
//  comment -> '@COMMENT' '{' value '}';
//  entry -> '@' key '{' key ',' key_value_list '}';
//  key_value_list -> key_equals_value (',' key_equals_value)*;
//  key_equals_value -> key '=' value;
//  value -> value_quotes | value_braces | key;
//  value_quotes -> '"' .*? '"'; // not quite
//  value_braces -> '{' .*? '"'; // not quite
function BibtexParser() {
  this.pos = 0;
  this.input = "";
  
  this.entries = {};
  this.strings = {
      JAN: "January",
      FEB: "February",
      MAR: "March",      
      APR: "April",
      MAY: "May",
      JUN: "June",
      JUL: "July",
      AUG: "August",
      SEP: "September",
      OCT: "October",
      NOV: "November",
      DEC: "December"
  };
  this.currentKey = "";
  this.currentEntry = "";
  

  this.setInput = function(t) {
    this.input = t;
  }
  
  this.getEntries = function() {
      return this.entries;
  }

  this.isWhitespace = function(s) {
    return (s == ' ' || s == '\r' || s == '\t' || s == '\n');
  }

  this.match = function(s) {
    this.skipWhitespace();
    if (this.input.substring(this.pos, this.pos+s.length) == s) {
      this.pos += s.length;
    } else {
      throw "Token mismatch, expected " + s + ", found " + this.input.substring(this.pos);
    }
    this.skipWhitespace();
  }

  this.tryMatch = function(s) {
    this.skipWhitespace();
    if (this.input.substring(this.pos, this.pos+s.length) == s) {
      return true;
    } else {
      return false;
    }
    this.skipWhitespace();
  }

  this.skipWhitespace = function() {
    while (this.isWhitespace(this.input[this.pos])) {
      this.pos++;
    }
    if (this.input[this.pos] == "%") {
      while(this.input[this.pos] != "\n") {
        this.pos++;
      }
      this.skipWhitespace();
    }
  }

  this.value_braces = function() {
    var bracecount = 0;
    this.match("{");
    var start = this.pos;
    while(true) {
      if (this.input[this.pos] == '}' && this.input[this.pos-1] != '\\') {
        if (bracecount > 0) {
          bracecount--;
        } else {
          var end = this.pos;
          this.match("}");
          return this.input.substring(start, end);
        }
      } else if (this.input[this.pos] == '{') {
        bracecount++;
      } else if (this.pos == this.input.length-1) {
        throw "Unterminated value";
      }
      this.pos++;
    }
  }

  this.value_quotes = function() {
    this.match('"');
    var start = this.pos;
    while(true) {
      if (this.input[this.pos] == '"' && this.input[this.pos-1] != '\\') {
          var end = this.pos;
          this.match('"');
          return this.input.substring(start, end);
      } else if (this.pos == this.input.length-1) {
        throw "Unterminated value:" + this.input.substring(start);
      }
      this.pos++;
    }
  }
  
  this.single_value = function() {
    var start = this.pos;
    if (this.tryMatch("{")) {
      return this.value_braces();
    } else if (this.tryMatch('"')) {
      return this.value_quotes();
    } else {
      var k = this.key();
      if (this.strings[k.toUpperCase()]) {
        return this.strings[k];
      } else if (k.match("^[0-9]+$")) {
        return k;
      } else {
        throw "Value expected:" + this.input.substring(start);
      }
    }
  }
  
  this.value = function() {
    var values = [];
    values.push(this.single_value());
    while (this.tryMatch("#")) {
      this.match("#");
      values.push(this.single_value());
    }
    return values.join("");
  }

  this.key = function() {
    var start = this.pos;
    while(true) {
      if (this.pos == this.input.length) {
        throw "Runaway key";
      }
    
      if (this.input[this.pos].match("[a-zA-Z0-9_:\\./-]")) {
        this.pos++
      } else {
        return this.input.substring(start, this.pos).toUpperCase();
      }
    }
  }

  this.key_equals_value = function() {
    var key = this.key();
    if (this.tryMatch("=")) {
      this.match("=");
      var val = this.value();
      return [ key, val ];
    } else {
      throw "... = value expected, equals sign missing:" + this.input.substring(this.pos);
    }
  }

  this.key_value_list = function() {
    var kv = this.key_equals_value();
    this.entries[this.currentEntry][kv[0]] = kv[1];
    while (this.tryMatch(",")) {
      this.match(",");
      // fixes problems with commas at the end of a list
      if (this.tryMatch("}")) {
        break;
      }
      kv = this.key_equals_value();
      this.entries[this.currentEntry][kv[0]] = kv[1];
    }
  }

  this.entry_body = function() {
    this.currentEntry = this.key();
    this.entries[this.currentEntry] = new Object();    
    this.match(",");
    this.key_value_list();
  }

  this.directive = function () {
    this.match("@");
    return "@"+this.key();
  }

  this.string = function () {
    var kv = this.key_equals_value();
    this.strings[kv[0].toUpperCase()] = kv[1];
  }

  this.preamble = function() {
    this.value();
  }

  this.comment = function() {
    this.value(); // this is wrong
  }

  this.entry = function() {
    this.entry_body();
  }

  this.bibtex = function() {
    while(this.tryMatch("@")) {
      var d = this.directive().toUpperCase();
      this.match("{");
      if (d == "@STRING") {
        this.string();
      } else if (d == "@PREAMBLE") {
        this.preamble();
      } else if (d == "@COMMENT") {
        this.comment();
      } else {
        this.entry();
      }
      this.match("}");
    }
  }
}

function BibtexDisplay() {
  this.fixValue = function (value) {
    value = value.replace(/\\glqq\s?/g, "&bdquo;");
    value = value.replace(/\\grqq\s?/g, '&rdquo;');
    value = value.replace(/\\ /g, '&nbsp;');
    value = value.replace(/\\url/g, '');
    value = value.replace(/---/g, '&mdash;');
    value = value.replace(/{\\"a}/g, '&auml;');
    value = value.replace(/\{\\"o\}/g, '&ouml;');
    value = value.replace(/{\\"u}/g, '&uuml;');
    value = value.replace(/{\\"A}/g, '&Auml;');
    value = value.replace(/{\\"O}/g, '&Ouml;');
    value = value.replace(/{\\"U}/g, '&Uuml;');
    value = value.replace(/\\ss/g, '&szlig;');
    value = value.replace(/\{(.*?)\}/g, '$1');
    return value;
  }
  
  this.displayBibtex2 = function(i, o) {
    var b = new BibtexParser();
    b.setInput(i);
    b.bibtex();

    var e = b.getEntries();
    var old = o.find("*");
  
    for (var item in e) {
      var tpl = $(".bibtex_template").clone().removeClass('bibtex_template');
      tpl.addClass("unused");
      
      for (var key in e[item]) {
      
        var fields = tpl.find("." + key.toLowerCase());
        for (var i = 0; i < fields.size(); i++) {
          var f = $(fields[i]);
          f.removeClass("unused");
          var value = this.fixValue(e[item][key]);
          if (f.is("a")) {
            f.attr("href", value);
          } else {
            var currentHTML = f.html() || "";
            if (currentHTML.match("%")) {
              // "complex" template field
              f.html(currentHTML.replace("%", value));
            } else {
              // simple field
              f.html(value);
            }
          }
        }
      }
    
      var emptyFields = tpl.find("span .unused");
      emptyFields.each(function (key,f) {
        if (f.innerHTML.match("%")) {
          f.innerHTML = "";
        }
      });
    
      o.append(tpl);
      tpl.show();
    }
    
    old.remove();
  }


  this.displayBibtex = function(input, output) {
    // parse bibtex input
    var b = new BibtexParser();
    b.setInput(input);
    b.bibtex();
    
    // save old entries to remove them later
    var old = output.find("*");    

    // iterate over bibTeX entries
    var entries = b.getEntries();
    for (var entryKey in entries) {
      var entry = entries[entryKey];
      
      // find template
      var tpl = $(".bibtex_template").clone().removeClass('bibtex_template');
      
      // find all keys in the entry
      var keys = [];
      for (var key in entry) {
        keys.push(key.toUpperCase());
      }
      
      // find all ifs and check them
      var removed = false;
      do {
        // find next if
        var conds = tpl.find(".if");
        if (conds.size() == 0) {
          break;
        }
        
        // check if
        var cond = conds.first();
        cond.removeClass("if");
        var ifTrue = true;
        var classList = cond.attr('class').split(' ');
        $.each( classList, function(index, cls){
          if(keys.indexOf(cls.toUpperCase()) < 0) {
            ifTrue = false;
          }
          cond.removeClass(cls);
        });
        
        // remove false ifs
        if (!ifTrue) {
          cond.remove();
        }
      } while (true);
      
      // fill in remaining fields 
      for (var index in keys) {
        var key = keys[index];
        var value = entry[key] || "";
        tpl.find("span:not(a)." + key.toLowerCase()).html(this.fixValue(value));
        tpl.find("a." + key.toLowerCase()).attr('href', this.fixValue(value));
      }
      
      output.append(tpl);
      tpl.show();
    }
    
    // remove old entries
    old.remove();
  }

}

function bibtex_js_draw() {
  $(".bibtex_template").hide();
  (new BibtexDisplay()).displayBibtex($("#bibtex_input").val(), $("#bibtex_display"));
}

// check whether or not jquery is present
if (typeof jQuery == 'undefined') {  
  // an interesting idea is loading jquery here. this might be added
  // in the future.
  alert("Please include jquery in all pages using bibtex_js!");
} else {
  // draw bibtex when loaded
  $(document).ready(function () {
    // check for template, add default
    if ($(".bibtex_template").size() == 0) {
      $("body").append("<div class=\"bibtex_template\"><div class=\"if author\" style=\"font-weight: bold;\">\n  <span class=\"if year\">\n    <span class=\"year\"></span>, \n  </span>\n  <span class=\"author\"></span>\n  <span class=\"if url\" style=\"margin-left: 20px\">\n    <a class=\"url\" style=\"color:black; font-size:10px\">(view online)</a>\n  </span>\n</div>\n<div style=\"margin-left: 10px; margin-bottom:5px;\">\n  <span class=\"title\"></span>\n</div></div>");
    }

    bibtex_js_draw();
  });
}